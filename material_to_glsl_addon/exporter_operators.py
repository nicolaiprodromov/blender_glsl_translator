import bpy
from bpy.props import StringProperty, BoolProperty
from bpy.types import Operator
from bpy_extras.io_utils import ExportHelper
import os

from .material_nodes_compiler import MaterialNodesCompiler


class MATERIAL_OT_export_glsl(Operator, ExportHelper):
    """Export the active material to GLSL fragment shader"""
    bl_idname = "material.export_glsl"
    bl_label = "Export to GLSL"
    bl_description = "Export the active material's node tree as a GLSL fragment shader"
    bl_options = {'REGISTER', 'UNDO'}
    
    # ExportHelper properties
    filename_ext = ".frag"
    filter_glob: StringProperty(
        default="*.frag;*.glsl",
        options={'HIDDEN'},
        maxlen=255,
    )
    
    # Additional properties
    include_textures_info: BoolProperty(
        name="Include Texture Info",
        description="Include texture information as comments in the shader",
        default=True,
    )
    
    force_valid_translation: BoolProperty(
        name="Force Valid Translation",
        description="Generate fallback values for unsupported nodes instead of errors",
        default=True,
    )
    
    @classmethod
    def poll(cls, context):
        return (context.material is not None and 
                context.material.use_nodes and 
                context.material.node_tree is not None)
    
    def execute(self, context):
        material = context.material
        
        if not material or not material.use_nodes or not material.node_tree:
            self.report({'ERROR'}, "No active material with nodes found")
            return {'CANCELLED'}
        
        try:
            # Create compiler instance
            compiler = MaterialNodesCompiler(material.node_tree)
            compiler.forceValidTranslation = self.force_valid_translation
            
            # Generate GLSL code
            glsl_code = compiler.translate()
            
            # Add header comment with material info
            header = f"""// Material: {material.name}
// Generated by Material to GLSL Exporter
// Based on Bentschi's Blender-GLSL-translator
// Date: {bpy.app.version_string}

"""
            
            # Add texture information if requested
            if self.include_textures_info and hasattr(compiler, 'textures') and compiler.textures:
                header += "// Textures used:\n"
                for i, texture_name in enumerate(compiler.textures):
                    header += f"// [{i}] {texture_name}\n"
                header += "\n"
            
            # Add error information if any
            if hasattr(compiler, 'errors') and compiler.errors:
                header += f"// Translation Errors ({len(compiler.errors)}):\n"
                for error in compiler.errors:
                    header += f"// - {error}\n"
                header += "\n"
            
            full_code = header + glsl_code
            
            # Write to file
            with open(self.filepath, 'w', encoding='utf-8') as f:
                f.write(full_code)
            
            self.report({'INFO'}, f"GLSL shader exported to {self.filepath}")
            
            # Show summary in console
            print(f"\n=== GLSL Export Summary ===")
            print(f"Material: {material.name}")
            print(f"Output file: {self.filepath}")
            if hasattr(compiler, 'textures'):
                print(f"Textures used: {len(compiler.textures)}")
            if hasattr(compiler, 'errors'):
                print(f"Translation errors: {len(compiler.errors)}")
            print("===========================\n")
            
            return {'FINISHED'}
            
        except Exception as e:
            self.report({'ERROR'}, f"Export failed: {str(e)}")
            print(f"GLSL Export Error: {e}")
            import traceback
            traceback.print_exc()
            return {'CANCELLED'}
    
    def invoke(self, context, event):
        # Set default filename based on material name
        if context.material:
            material_name = context.material.name
            # Clean filename (remove invalid characters)
            import re
            clean_name = re.sub(r'[<>:"/\\|?*]', '_', material_name)
            self.filepath = clean_name + self.filename_ext
        
        context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}


class MATERIAL_OT_preview_glsl(Operator):
    """Preview the GLSL code for the active material in the text editor"""
    bl_idname = "material.preview_glsl"
    bl_label = "Preview GLSL"
    bl_description = "Generate and preview the GLSL code in Blender's text editor"
    bl_options = {'REGISTER', 'UNDO'}
    
    @classmethod
    def poll(cls, context):
        return (context.material is not None and 
                context.material.use_nodes and 
                context.material.node_tree is not None)
    
    def execute(self, context):
        material = context.material
        
        if not material or not material.use_nodes or not material.node_tree:
            self.report({'ERROR'}, "No active material with nodes found")
            return {'CANCELLED'}
        
        try:
            # Create compiler instance
            compiler = MaterialNodesCompiler(material.node_tree)
            
            # Generate GLSL code
            glsl_code = compiler.translate()
            
            # Create header
            header = f"""// Material: {material.name}
// Generated by Material to GLSL Exporter
// Preview mode - not saved to file

"""
            
            # Add texture and error info
            if hasattr(compiler, 'textures') and compiler.textures:
                header += "// Textures used:\n"
                for i, texture_name in enumerate(compiler.textures):
                    header += f"// [{i}] {texture_name}\n"
                header += "\n"
            
            if hasattr(compiler, 'errors') and compiler.errors:
                header += f"// Translation Errors ({len(compiler.errors)}):\n"
                for error in compiler.errors:
                    header += f"// - {error}\n"
                header += "\n"
            
            full_code = header + glsl_code
            
            # Create or update text block
            text_name = f"{material.name}_shader.frag"
            
            # Remove existing text block if it exists
            if text_name in bpy.data.texts:
                bpy.data.texts.remove(bpy.data.texts[text_name])
            
            # Create new text block
            text_block = bpy.data.texts.new(text_name)
            text_block.write(full_code)
            
            # Switch to Text Editor if possible
            for area in context.screen.areas:
                if area.type == 'TEXT_EDITOR':
                    area.spaces[0].text = text_block
                    break
            else:
                # If no text editor is open, report where to find the preview
                self.report({'INFO'}, f"GLSL preview created as '{text_name}' in Text Editor")
            
            self.report({'INFO'}, f"GLSL preview generated for material '{material.name}'")
            return {'FINISHED'}
            
        except Exception as e:
            self.report({'ERROR'}, f"Preview failed: {str(e)}")
            print(f"GLSL Preview Error: {e}")
            import traceback
            traceback.print_exc()
            return {'CANCELLED'}


def register():
    bpy.utils.register_class(MATERIAL_OT_export_glsl)
    bpy.utils.register_class(MATERIAL_OT_preview_glsl)


def unregister():
    bpy.utils.unregister_class(MATERIAL_OT_preview_glsl)
    bpy.utils.unregister_class(MATERIAL_OT_export_glsl)
