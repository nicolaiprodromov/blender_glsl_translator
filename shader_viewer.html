<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLSL Shader Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 5px;
            background: #000000;
            color: #fff;
            font-family: monospace;
        }
        
        #container {
            display: flex;
            gap: 5px;
            height: calc(100vh - 10px);
        }
        
        #controls {
            width: 500px;
            background: #121212;
            padding: 0px 20px 0px 20px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        #viewer {
            flex: 1;
            background: #242424;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        canvas {
            width: 90%;
            height: 90%;
            max-width: 100%;
            max-height: 100%;
            border: 1px solid #555;
        }
        
        textarea {
            width: calc(100% - 20px);
            height: 200px;
            background: #1e1e1e;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            overflow-y: hidden;
        }
        
        button {
            background: #050505;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 0;
            width: 100%;
            transition: background 0.2s ease-in-out;
        }
        
        button:hover {
            background: #232323;
        }
        
        .error {
            background: #ff4444;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            white-space: pre-wrap;
        }
        
        .success {
            background: #5a5a5a;
            color: rgb(0, 0, 0);
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        input[type="file"] {
            margin: 10px 0;
            color: #fff;
        }
        
        .control-group {
            margin: 0px 0;
        }
        
        label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        .uniform-controls {
            border-top: 1px solid #555;
            padding-top: 5px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h2>GLSL Shader Viewer</h2>
            
            <div class="control-group">
                <label>Load Shader File:</label>
                <input type="file" id="fileInput" accept=".frag,.glsl">
                <button onclick="loadDefaultShader()">Load Test Shader</button>
            </div>
            
            <div class="control-group">
                <label>Fragment Shader:</label>
                <textarea id="fragmentShader" placeholder="Paste your fragment shader here..."></textarea>
                <button onclick="compileShader()">Compile & Run</button>
            </div>
            
            <div class="uniform-controls">
                <h3>Controls</h3>
                <div class="control-group">
                    <label>Time: <span id="timeValue">0.0</span></label>
                    <input type="range" id="timeSlider" min="0" max="10" step="0.1" value="0">
                </div>
                
                <div class="control-group">
                    <label>Animation:</label>
                    <button id="playButton" onclick="toggleAnimation()">Play</button>
                </div>
                
                <div class="control-group">
                    <label>Render Quality: <span id="qualityValue">1.0x</span></label>
                    <input type="range" id="qualitySlider" min="0.5" max="2.0" step="0.1" value="1.0">
                    <button onclick="resizeCanvas()">Apply Quality</button>
                </div>
            </div>
            
            <div id="messages"></div>
        </div>
        
        <div id="viewer">
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <script>
        let gl, program, animationId;
        let isPlaying = false;
        let startTime = Date.now();
        
        // Initialize WebGL
        function initWebGL() {
            const canvas = document.getElementById('canvas');
            gl = canvas.getContext('webgl2', {
                antialias: false,
                alpha: false,
                depth: false,
                stencil: false,
                preserveDrawingBuffer: false,
                powerPreference: "high-performance"
            }) || canvas.getContext('webgl', {
                antialias: false,
                alpha: false,
                depth: false,
                stencil: false,
                preserveDrawingBuffer: false,
                powerPreference: "high-performance"
            });
            
            if (!gl) {
                showError('WebGL not supported');
                return false;
            }
            
            // Set up canvas sizing for high-DPI displays
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            return true;
        }
        
        function resizeCanvas() {
            const canvas = document.getElementById('canvas');
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            
            // Get device pixel ratio for high-DPI displays
            const pixelRatio = window.devicePixelRatio || 1;
            
            // Get quality multiplier from slider
            const qualitySlider = document.getElementById('qualitySlider');
            const qualityMultiplier = qualitySlider ? parseFloat(qualitySlider.value) : 1.0;
            
            // Update quality display
            const qualityValue = document.getElementById('qualityValue');
            if (qualityValue) {
                qualityValue.textContent = qualityMultiplier.toFixed(1) + 'x';
            }
            
            // Set the internal resolution to match display size * pixel ratio * quality
            const width = Math.floor(displayWidth * pixelRatio * qualityMultiplier);
            const height = Math.floor(displayHeight * pixelRatio * qualityMultiplier);
            
            // Only resize if dimensions changed
            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
                
                // Update viewport when canvas resizes
                if (gl) {
                    gl.viewport(0, 0, width, height);
                }
                
                // Re-render with new resolution
                if (program) {
                    render();
                }
            }
        }
        
        // Vertex shader (simple quad)
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_texCoord;
            varying vec3 v_position;
            varying vec3 v_normal;
            varying vec3 v_objectNormal;
            
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = a_position * 0.5 + 0.5;
                v_position = vec3(a_position, 0.0);
                v_normal = vec3(0.0, 0.0, 1.0);
                v_objectNormal = vec3(0.0, 0.0, 1.0);
            }
        `;
        
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const error = gl.getShaderInfoLog(shader);
                gl.deleteShader(shader);
                throw new Error(`Shader compilation error: ${error}`);
            }
            
            return shader;
        }
        
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                const error = gl.getProgramInfoLog(program);
                gl.deleteProgram(program);
                throw new Error(`Program linking error: ${error}`);
            }
            
            return program;
        }
        
        function adaptShaderForWebGL(shaderSource) {
            // Convert OpenGL shader to WebGL compatible format
            let adapted = shaderSource;
            
            // Remove version directive
            adapted = adapted.replace(/#version\s+\d+.*?\n/g, '');
            
            // Remove inline error comments that break compilation
            adapted = adapted.replace(/\/\*\s*NODE_TYPE_UNKNOWN\([^)]*\)\s*\*\//g, '');
            adapted = adapted.replace(/\/\*\s*CONVERSION_UNKNOWN\([^)]*\)\s*\*\//g, '');
            adapted = adapted.replace(/\/\*\s*[A-Z_]+\([^)]*\)\s*\*\//g, '');
            
            // For fragment shaders, convert layout in to varying (inputs from vertex shader)
            adapted = adapted.replace(/layout\(location=\d+\)\s+in\s+(\w+)\s+(\w+);/g, 'varying $1 $2;');
            
            // Remove layout out declarations (fragment shader output)
            adapted = adapted.replace(/layout\(location=\d+\)\s+out\s+(\w+)\s+(\w+);/g, '');
            
            // Handle fragment shader output
            if (adapted.includes('fragColor')) {
                adapted = adapted.replace(/fragColor\s*=/g, 'gl_FragColor =');
            }
            
            // Fix broken TEX_COORD nodes - replace vec3(0.0,0.0,0.0) with actual texture coordinates
            adapted = adapted.replace(/vec3\s*\(\s*0\.0\s*,\s*0\.0\s*,\s*0\.0\s*\)\s*;/g, 'vec3(v_texCoord, 0.0);');
            
            // Add precision for fragment shader
            if (adapted.includes('main()')) {
                adapted = 'precision highp float;\nprecision highp int;\n' + adapted;
            }
            
            return adapted;
        }
        
        function compileShader() {
            try {
                const fragmentSource = document.getElementById('fragmentShader').value;
                
                if (!fragmentSource.trim()) {
                    showError('Please enter a fragment shader');
                    return;
                }
                
                // Adapt shader for WebGL
                const adaptedFragmentSource = adaptShaderForWebGL(fragmentSource);
                
                // Debug: show adapted shader
                console.log('Adapted shader:', adaptedFragmentSource);
                
                // Create shaders
                const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, adaptedFragmentSource);
                
                // Create program
                if (program) {
                    gl.deleteProgram(program);
                }
                program = createProgram(gl, vertexShader, fragmentShader);
                
                // Set up geometry
                const positions = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1
                ]);
                
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                
                const positionLocation = gl.getAttribLocation(program, 'a_position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                
                showSuccess('Shader compiled successfully!');
                render();
                
            } catch (error) {
                console.error('Full error:', error);
                showError(`Compilation failed:\n${error.message}`);
            }
        }
        
        function render() {
            if (!program) return;
            
            const canvas = document.getElementById('canvas');
            
            // Ensure canvas is properly sized
            resizeCanvas();
            
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.useProgram(program);
            
            // Update time value for display
            const currentTime = isPlaying ? (Date.now() - startTime) / 1000.0 : parseFloat(document.getElementById('timeSlider').value);
            document.getElementById('timeValue').textContent = currentTime.toFixed(2);
            
            // Update slider if playing
            if (isPlaying) {
                document.getElementById('timeSlider').value = Math.min(currentTime, 10);
            }
            
            // Set uniforms if they exist
            const timeLocation = gl.getUniformLocation(program, 'iTime');
            if (timeLocation) {
                gl.uniform1f(timeLocation, currentTime);
            }
            
            // Blender time uniforms
            const uTimeLocation = gl.getUniformLocation(program, 'u_time');
            if (uTimeLocation) {
                gl.uniform1f(uTimeLocation, currentTime);
            }
            
            const uFrameLocation = gl.getUniformLocation(program, 'u_frame');
            if (uFrameLocation) {
                const frame = currentTime * 24.0; // 24 fps
                gl.uniform1f(uFrameLocation, frame);
            }
            
            // Use actual canvas dimensions for resolution uniform
            const resolutionLocation = gl.getUniformLocation(program, 'iResolution');
            if (resolutionLocation) {
                gl.uniform3f(resolutionLocation, canvas.width, canvas.height, 1.0);
            }
            
            // Clear and draw
            gl.clearColor(0.1, 0.1, 0.1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            if (isPlaying) {
                animationId = requestAnimationFrame(render);
            }
        }
        
        function toggleAnimation() {
            const button = document.getElementById('playButton');
            if (isPlaying) {
                isPlaying = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                button.textContent = 'Play';
                button.style.background = '#4CAF50';
            } else {
                isPlaying = true;
                startTime = Date.now() - parseFloat(document.getElementById('timeSlider').value) * 1000;
                button.textContent = 'Pause';
                button.style.background = '#ff6b6b';
                render();
            }
        }
        
        function showError(message) {
            const messagesDiv = document.getElementById('messages');
            messagesDiv.innerHTML = `<div class="error">Error: ${message}</div>`;
        }
        
        function showSuccess(message) {
            const messagesDiv = document.getElementById('messages');
            messagesDiv.innerHTML = `<div class="success">${message}</div>`;
        }
        
        function loadDefaultShader() {
            const defaultShader = `// Test shader
struct material
{
    vec4 color;
    float metallic;
    vec4 specular;
    float roughness;
    float ior;
    vec4 emission;
    float alpha;
    vec3 normal;
};

varying vec2 v_texCoord;
varying vec3 v_position;
varying vec3 v_normal;
varying vec3 v_objectNormal;

void main()
{
    vec2 var2 = v_texCoord;
    float var1 = length(var2);
    material mat = material(vec4(vec3(var1),1.0),0.0,vec4(0.5,0.5,0.5,1.0),0.5,1.45,vec4(0.0,0.0,0.0,1.0),1.0,vec3(0.0,0.0,0.0));
    
    gl_FragColor = vec4(mat.color.xyz, mat.alpha);
}`;
            
            document.getElementById('fragmentShader').value = defaultShader;
            compileShader();
        }
        
        // File loading
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    document.getElementById('fragmentShader').value = e.target.result;
                    compileShader();
                };
                reader.readAsText(file);
            }
        });
        
        // Time slider
        document.getElementById('timeSlider').addEventListener('input', function(e) {
            if (!isPlaying) {
                render();
            }
        });
        
        // Quality slider
        document.getElementById('qualitySlider').addEventListener('input', function(e) {
            const qualityValue = document.getElementById('qualityValue');
            qualityValue.textContent = parseFloat(e.target.value).toFixed(1) + 'x';
        });
        
        // Initialize
        window.addEventListener('load', function() {
            if (initWebGL()) {
                loadDefaultShader();
            }
        });
    </script>
</body>
</html>
